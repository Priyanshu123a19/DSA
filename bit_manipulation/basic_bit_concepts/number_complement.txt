problem statement
476. Number Complement
Solved
Easy
Topics
premium lock iconCompanies

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

    For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.

Given an integer num, return its complement.

 

Example 1:

Input: num = 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.

Example 2:

Input: num = 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.




solution......................................................................................................................................


class Solution {
public:
    int findComplement(int num) {
        //here we can use the concept of bit masking

        //step 1....we create a bit mask of the same size as that of the significant bits in the num
        //step 2....now the mask is like 111 for a num having 3 signifaicant bits
        //eg if 5=101  then its mask will be 111

        if(num==0){
            return 0;
        }

        //lets do till step 2
        unsigned int mask=1;
        //now over here we will make the mask
        while(mask<=num){
            // see this eg to understand
// 1	int findComplement(int num = 5)	5	(uninitialized)	(uninitialized)	Function is called with num = 5.
// 2	if (num == 0)	5	(uninitialized)	(uninitialized)	5 == 0 is false. The if block is skipped.
// 3	unsigned int mask = 1;	5	1	00000001	The mask is initialized to 1.
// 4	while (mask <= num)	5	1	00000001	Loop 1: Check if 1 <= 5. This is true. The loop body executes.
// 5	mask <<= 1;	5	2	00000010	mask is shifted left by one bit. (1 becomes 2).
// 6	while (mask <= num)	5	2	00000010	Loop 2: Check if 2 <= 5. This is true. The loop body executes.
// 7	mask <<= 1;	5	4	00000100	mask is shifted left by one bit. (2 becomes 4).
// 8	while (mask <= num)	5	4	00000100	Loop 3: Check if 4 <= 5. This is true. The loop body executes.
// 9	mask <<= 1;	5	8	00001000	mask is shifted left by one bit. (4 becomes 8).
// 10	while (mask <= num)	5	8	00001000	Loop 4: Check if 8 <= 5. This is false. The loop terminates.
// 11	return (mask - 1) ^ num;	5	8	00001000	This is the final calculation. Let's break it down:
            mask<<=1;
        }
        //now over here we will make the final ans
        //as u have seen the current mask is 1000 after mask-1 it becomes ===111 perfect mask for the 3 significant bit number
        return (mask-1)^num;
    }
};