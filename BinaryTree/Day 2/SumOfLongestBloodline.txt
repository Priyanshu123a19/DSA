Given a binary tree root[], you need to find the sum of the nodes on the longest path from the root to any leaf node. If two or more paths have the same length, the path with the maximum sum of node values should be considered.

Examples:

Input: root[] = [4, 2, 5, 7, 1, 2, 3, N, N, 6, N]
 
Output: 13
Explanation:

The highlighted nodes (4, 2, 1, 6) above are part of the longest root to leaf path having sum = (4 + 2 + 1 + 6) = 13

Input: root[] = [1, 2, 3, 4, 5, 6, 7]

Output: 11
Explanation: 

The longest root-to-leaf path is 1 -> 3 -> 7, with sum 11.

Input: root[] = [10, 5, 15, 3, 7, N, 20, 1]

Output: 19
Explanation: 

The longest root-to-leaf path is 10 -> 5 -> 3 -> 1 with a sum of 10 + 5 + 3 + 1 = 19.

Constraints:
1 <= number of nodes <= 106
0 <= node->data <= 104




solution..................................................................................................


/*
class Node {
  public:
    int data;
    Node *left;
    Node *right;

    Node(int x) {
        data = x;
        left = NULL;
        right = NULL;
    }
}; */

class Solution {
  public:
    void helper(Node*root , int currentSum,int currentLen,int &maxLen,int &ans){
        //base condition would be reaching the dead node
        if(root==NULL){
            return;
        }
        
        currentSum+=root->data;
        currentLen++;
        //calling out the recursiion for both the sides
        if(root->left==NULL && root->right ==NULL){
            if(currentLen>=maxLen){
                if(currentLen>maxLen){
                    maxLen=currentLen;
                    ans=currentSum;
                }else{
                    if(currentSum>ans){
                        ans=currentSum;
                    }
                }
            }
        }
        helper(root->left,currentSum,currentLen,maxLen,ans);
        helper(root->right,currentSum,currentLen,maxLen,ans);
    }
    int sumOfLongRootToLeafPath(Node *root) {
        // code here
        if(root==NULL){
            return 0;
        }

        //now just use the recusrion and find the longest path
        int ans=0;
        if(root->left==NULL && root->right==NULL){
            return root->data;
        }
        int currentSum=0;
        int currentLen=0;
        int maxLen=0;
        helper(root,currentSum,currentLen,maxLen,ans);
        return ans;
    }
};