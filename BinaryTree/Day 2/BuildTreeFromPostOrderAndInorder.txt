105. Construct Binary Tree from Preorder and Inorder Traversal
Solved
Medium
Topics
premium lock iconCompanies

Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.

 

Example 1:

Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

Example 2:

Input: preorder = [-1], inorder = [-1]
Output: [-1]

 

Constraints:

    1 <= preorder.length <= 3000
    inorder.length == preorder.length
    -3000 <= preorder[i], inorder[i] <= 3000
    preorder and inorder consist of unique values.
    Each value of inorder also appears in preorder.
    preorder is guaranteed to be the preorder traversal of the tree.
    inorder is guaranteed to be the inorder traversal of the tree.

solution.............................................................................




/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* helper(vector<int> &preorder, vector<int> &inorder,int &index,int inOrderStart,int inOrderLast,map<int,int>&mp,int n){
        //now over here we can update more elements and add them and then again call the recurion to build out their left and rifht part
        if(index>n || inOrderStart>inOrderLast){
            return NULL;
        }

        //getting the current node ready
        int element=preorder[index++];
        int position = mp[element];
        TreeNode* root=new TreeNode(element);

        //now get the right and left part for it
        root->left=helper(preorder,inorder,index,inOrderStart,position-1,mp,n);
        root->right=helper(preorder,inorder,index,position+1,inOrderLast,mp,n);

        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        map<int,int>NodeToIndex;
        int n= inorder.size();
        for(int i=0;i<n;i++){
            //now over here we can get more of these things done
            NodeToIndex[inorder[i]]=i;
        }

        //now finally we can the main function called
        //algo
        //start with the first and last node bound in the inorder
        //get the current element from the preorder
        //make a new node and insert it
        //insert it
        //recursino call from the start bound till this current element indecx in the inorder
        //recursive call from the this element index+1 till end of the bound
        //thats all
        int index=0;
        TreeNode* ans=helper(preorder,inorder,index,0,n-1,NodeToIndex,n);
        return ans;
    }
};