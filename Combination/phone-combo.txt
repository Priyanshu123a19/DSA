problem statement
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

 

Example 1:

Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

Example 2:

Input: digits = ""
Output: []

Example 3:

Input: digits = "2"
Output: ["a","b","c"]




answer........

class Solution {
public:
    void helper(vector<string>&ans,string &current,unordered_map<char,string>mp,string digits){
        //base case
        if(current.size()==digits.size()){
            ans.push_back(current);
            return;
        }
        //here we will be making 4 different cases for our backtracking cases
        if(current.size()==0 && current.size()+1<=digits.size()){
            //explore the map at the 0th index
            for(int i=0;i<mp[digits[current.size()]].size();i++){
                //just add the elements one by one and call recursion
                current.push_back(mp[digits[current.size()]][i]);
                helper(ans,current,mp,digits);
                current.pop_back();
            }
        }
        if(current.size()==1 && current.size()+1<=digits.size()){
            //explore the map at the 0th index
            for(int i=0;i<mp[digits[current.size()]].size();i++){
                //just add the elements one by one and call recursion
                current.push_back(mp[digits[current.size()]][i]);
                helper(ans,current,mp,digits);
                current.pop_back();
            }
        }
        if(current.size()==2 && current.size()+1<=digits.size()){
            //explore the map at the 0th index
            for(int i=0;i<mp[digits[current.size()]].size();i++){
                //just add the elements one by one and call recursion
                current.push_back(mp[digits[current.size()]][i]);
                helper(ans,current,mp,digits);
                current.pop_back();
            }
        }
        if(current.size()==3 && current.size()+1<=digits.size()){
            //explore the map at the 0th index
            for(int i=0;i<mp[digits[current.size()]].size();i++){
                //just add the elements one by one and call recursion
                current.push_back(mp[digits[current.size()]][i]);
                helper(ans,current,mp,digits);
                current.pop_back();
            }
        }

    }
    vector<string> letterCombinations(string digits) {
        //map the digits ans all by yourself
        vector<string>ans;
        string current;
        if(digits.size()==0){
            return ans;
        }
        unordered_map<char,string>mp={
            {'2',"abc"},
            {'3',"def"},
            {'4',"ghi"},
            {'5',"jkl"},
            {'6',"mno"},
            {'7',"pqrs"},
            {'8',"tuv"},
            {'9',"wxyz"}
        };
        helper(ans,current,mp,digits);
        return ans;
    }
};